<!DOCTYPE html>
<!-- Copyright (c) 2023-2025 Hermann von Borries
 MIT License-->
 <html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="stylesheet" type="text/css" href="skeleton.css">
</head>


<body id="pagebody">

<script type="text/javascript" src="/static/common.js"></script>
<script type="text/javascript" src="/static/translations.js"></script>

<span id="changes_auto" style="display:none">Los cambios se guardan autom√°ticamente cada par de segundos.</span>
<br>

<span id="wait_for_update"></span>

<div class="tableFixHead">

    <table>
        <thead id="tunelistHead"></thead>
        <tbody id="tunelistBody"></tbody>
    </table>
</div>
<br>
<button onclick="showAsTable()">Formato de tabla para copiar</button>
<div class="footerdiv"></div>

<div id="modalLyrics" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeLyrics()">&times;</span>
      <br>
      <textarea id="lyricsText" rows="30"></textarea>
      <br>
      <button onclick="saveLyrics()">Guardar</button>
    </div>
  
</div>
</body>

<script>
// (c) Copyright 2025 Hermann Paul von Borries. All rights reserved.
// MIT License


// PageHeader.setTitle(headerTitle, upAction)
let pageHeader = new PageHeader();
pageHeader.setTitle( "Tunelib editor", "index"  );
pageHeader.setBannerInfo( "‚úÖ" + tlt("Al d√≠a."), "‚ùó" );


async function getTuneList( ) {
    let wfu = document.getElementById( "wait_for_update" ) ;
    wfu.innerHTML = "";
	let resp = await fetch_json( "/start_tunelib_sync" ) ;
    while( true ){
        let resp = await fetch_json( "/tunelib_sync_progress" );
        wfu.innerHTML =  "<p>" + resp["progress"] ;
        if( resp["progress"].includes( "***end***") ){
            // wfu.innerHTML to be cleared at end of this function.
            break ;
        }
        await sleep_ms( 1000 );
        
    }
    // Update with latest information
    tunelibCache.drop();
    lyricsCache.drop();

    let tunelib = await tunelibCache.get() ;
    let tunelist = [];
    for( const [key, tune] of Object.entries(tunelib)) {
        tunelist.push( tune ) ;
    }
    sortTunelist( tunelist );
    await updateForm( tunelist ) ;

    await sleep_ms( 5_000 ) ;
    wfu.innerHTML = "";
    showHideElement( "changes_auto", true );
}

let CHANGED_FIELDS = [] ;

let HEADER_MAP = [ TLCOL_TITLE, TLCOL_GENRE, TLCOL_AUTHOR, TLCOL_YEAR, TLCOL_AUTOPLAY,
    TLCOL_RATING, TLCOL_INFO, TLCOL_LYRICS, TLCOL_TIME, TLCOL_DATEADDED,
    TLCOL_FILENAME, TLCOL_SIZE ] ;
let TABLE_HEADER = map_tlcol_names( HEADER_MAP );
TABLE_HEADER.push( tlt("Borrar")  ); // last column is delete button

async function updateForm( tunelist ){

    let tunelistHead = document.getElementById("tunelistHead");
    if( tunelistHead.innerHTML == "" ){
        // Header not defined, make header row
        let row = document.createElement( "tr" );
        for( let h of TABLE_HEADER ){
            let th = document.createElement( "th" );
            th.innerHTML = h ;
            row.appendChild( th );
        }
        tunelistHead.appendChild( row );
    }

    let tunelistBody = document.getElementById( "tunelistBody" );
    tunelistBody.innerHTML = "";
    let lyrics = await lyricsCache.get();
	for( let i in tunelist ) {
        let tune = tunelist[i]; // have a new variable for each iteration
        // that is needed for function() closure.

        let row = insertRow( tunelistBody, ["","","","","","","","","","","","",""]);
        let rowid = "row" + i;
        row.id = rowid;
        // input box id is tuneid.tlcol_number
        row.cells[0].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_TITLE,20,tune[TLCOL_TITLE]));
        row.cells[1].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_GENRE,20,tune[TLCOL_GENRE]));
        row.cells[2].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_AUTHOR,20,tune[TLCOL_AUTHOR]));
        row.cells[3].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_YEAR,6,tune[TLCOL_YEAR])) ;
	    row.cells[4].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_AUTOPLAY,-1,tune[TLCOL_AUTOPLAY]) ) ;
        row.cells[5].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_RATING,6,tune[TLCOL_RATING]) );
        row.cells[6].appendChild( makeBoxField(tune[TLCOL_ID],""+TLCOL_INFO,20,tune[TLCOL_INFO]) ) ;
        let lyricsButton = document.createElement( "button" );
        lyricsButton.classList.add( "smallbutton" );
        lyricsButton.onclick = function(){ editLyrics( tune[TLCOL_ID] ) };
        lyricsButton.id = `lyrics_${tune[TLCOL_ID]}`;
        if( tune[TLCOL_LYRICS]) {
            lyricsButton.innerText = "Edit";
        }
        else{
            lyricsButton.innerText = "Add";
        }
        
        row.cells[7].appendChild( lyricsButton );

        row.cells[8].innerText = formatMilliMMSS( tune[TLCOL_TIME] );
        row.cells[8].style.textAlign = "right";
        row.cells[9].innerText = tune[TLCOL_DATEADDED];
        row.cells[10].innerText = tune[TLCOL_FILENAME];

        row.cells[11].innerText = tune[TLCOL_SIZE];
        row.cells[11].style.textAlign = "right";
        let deleteButton = document.createElement( "button" );
        deleteButton.classList.add( "smallbutton" );
        deleteButton.onclick = function(){ deleteTuneFile( tune[TLCOL_ID], rowid ) };
        deleteButton.innerHTML = "üóëÔ∏è";
        row.cells[12].appendChild( deleteButton );
    }   
 
	CHANGED_FIELDS = [];
}
    

function makeBoxField( tuneid, name, size, value ){
    const id = `${tuneid}.${name}`;
    if( size == -1 ) {
        let checkbox = document.createElement( "input" );
        checkbox.type = "checkbox";
        checkbox.name = tuneid ;
        checkbox.id = id ;
        checkbox.checked = value ;
        checkbox.onchange = function(){ markField(id) };
        return checkbox ; 
    }
    
    let textBox = document.createElement( "input" );
    textBox.name = tuneid ;
    textBox.id = id ;
    textBox.size = size ;
    textBox.value = value ;
    textBox.oninput = function() { markField(id) };
    return textBox ;
}

function markField( id ){
    if( !CHANGED_FIELDS.includes(id) ){
        CHANGED_FIELDS.push( id );
    }
    const d = document.getElementById( id ) ;
    d.style.backgroundColor = cream ;
    // record time to delay save() until it's quiet.
    lastFieldUpdate = Date.now();
}
    

async function save_process( ){
    // Send json with changed fields only
    // items of newjson are of the form needed for
    // tunelib., i.e. a list of
    // [TLOP_FIELD, tuneid, tlcol, value]
    const TLOP_FIELD = 3 ;
    while( true ){
        await sleep_ms( 1000 );
        if( CHANGED_FIELDS.length == 0 ){
            continue ; // nothing to save
        }
        let t1 = Date.now();
            // wait a few seconds without a change to
            // gather several changes in one interchange
        if( (t1 - lastFieldUpdate) < 3000 ){
            // Compares to 12 seconds in tunemanager.py ((time.time() - file_stat[8]) < 12)
            // It is better that time here is a bit smaller than tunemanager.
            continue;
        }
        let newjson = [];
        // Make a copy and clear CHANGED_FIELDS now to avoid
        // possible race condition due to await below.
        // CHANGED_FIELDS is a list of id of changed DOM fields
        let cfcopy = [...CHANGED_FIELDS];
        CHANGED_FIELDS = [];
        for( let eleid of cfcopy ){
            let ele = document.getElementById(eleid)
            // split id into [tuneid, tlcol]  
            let tt = ele.id.split(".");
            if( ele.type == "text" ){
                newjson.push( [ TLOP_FIELD, tt[0], parseInt(tt[1]), ele.value ] ) ;
            }
            else if( ele.type == "checkbox" ){
                newjson.push( [ TLOP_FIELD, tt[0], parseInt(tt[1]), ele.checked?1:0 ]);
            }
        
        }
        // newjson now is a list of lists, each of the form
        // [TLOP_FIELD, tuneid, tlcol, value]
        // Unchanged fields are not transmitted.
        resp = await fetch_json( "/save_tunelib", newjson ) ;
        // Now that the microcontroller has the data, unmark the fields.
        for( let eleid of cfcopy ){
            let ele = document.getElementById(eleid)
            // split id into [tuneid, tlcol]  
            if( ele.type == "text" ){
                ele.style.backgroundColor = "white" ;
            }
        }
        // from this point on, progress tracks the state of the update.
    }
}

    
   
function sortTunelist( tunelist){
    function compareFn(a, b ){
        return a[TLCOL_TITLE].localeCompare( b[TLCOL_TITLE]);
    } 
    tunelist.sort( compareFn );
}
let currentTuneid = ""; // the tuneid with lyrics being edited
async function editLyrics(tuneid){
    let modal = document.getElementById( "modalLyrics" );
    let lyricsText = document.getElementById( "lyricsText" );
    currentTuneid = tuneid ;
    lyricsText.cols = Math.round(window.innerWidth/12) ;
    lyricsText.rows = Math.round(window.innerHeight/5);
    // If no entry, then lyrics is empty ""
    lyricsText.value = await lyricsCacheTuneid( currentTuneid );
    modal.style.display = "block";
    // at next refresh, button name gets recalculated
    document.getElementById(`lyrics_${tuneid}`).innerText = "Edit";
    return ;
}

async function closeLyrics(){
    let modal = document.getElementById( "modalLyrics" );
 
    modal.style.display = "none";
    currentTuneid = "" ;
}

async function saveLyrics(){
    if( currentTuneid == ""){
        alert("No current tuneid, cannot save");
        closeLyrics();
    }
    let modal = document.getElementById( "modalLyrics" );
    let lyricsText = document.getElementById("lyricsText");
    ly = lyricsText.value;
    let data = {"tuneid": currentTuneid, "lyrics": ly };
    let resp = await fetch_json( "/save_lyrics", data );
    closeLyrics() ;
    showPopup("", "Lyrics saved" ) ;
    // If /save_lyrics is successful, we could change button name
    // to "Edit" immediately (not only on next refresh?)
    lyricsCache.drop();
    return ;
}

async function showAsTable(){
    let tunelib = await tunelibCache.get() ;
    let table = document.createElement( "table");
    let tableHead = document.createElement( "thead" );
    let headRow = document.createElement( "tr" );
    for( let h of TABLE_HEADER ){
        let th = document.createElement( "th" );
        th.innerHTML = h ;
        headRow.appendChild( th );
    }
    tableHead.appendChild( headRow );
    table.appendChild( tableHead );

    let tableBody = document.createElement( "tbody" );
    tableBody.innerHTML = "";
    for( let tuneid in tunelib  ){
        let tune = tunelib[tuneid];
        let row = insertRow( tableBody,[tune[TLCOL_TITLE],tune[TLCOL_GENRE],
            tune[TLCOL_AUTHOR], tune[TLCOL_YEAR], tune[TLCOL_RATING],
            tune[TLCOL_INFO], formatMilliMMSS( tune[TLCOL_TIME]),
            tune[TLCOL_DATEADDED], tune[TLCOL_FILENAME],
            tune[TLCOL_SIZE]]);
        tableBody.appendChild( row );
    }
    table.appendChild( tableBody );
    // Only show the table
    document.body.innerHTML = "";
    document.body.appendChild( table );
}

async function deleteTuneFile( tuneid, rowid ){
    let tunelib = await tunelibCache.get() ;
    let tune = tunelib[tuneid];
    if( tune == undefined ){
        return;
    }
    if( confirm(`Do you want to delete the MIDI file ${tune[TLCOL_FILENAME]} on the microcontroller?`)){
        let path = "/tunelib/" + tune[TLCOL_FILENAME];
        let data = await fetch_json("/delete_file", {"delete_filename": path } );
        // empty response means ok, file was deleted
        if( data["error"] == undefined ){
            // make row vanish from table
            document.getElementById(rowid).style.display = "none";
        }
    }
}


translate_html();
// fill form with tunelib
getTuneList() ;
// save in background
save_process()


commonGetProgress.setSleep( 2_000 );
// No need to register updateProgress function
commonGetProgress.startBackground();
</script>
</html>