
<!DOCTYPE html>
<!-- Copyright (c) 2023-2025 Hermann von Borries
 MIT License-->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="stylesheet" type="text/css" href="skeleton.css">
</head>
<body>

<script type="text/javascript" src="/static/common.js"></script>
<script type="text/javascript" src="/static/translations.js"></script>

<table id="main_info_table">
	<tbody>
		<tr id="request_row" style="display:none"><td>Pedido por</td><td id="spectator_name"></td></tr>
		<tr><td colspan="2"><h2><span is="tune-title" id="title"></span></h2></td></tr>
		<tr id="controlButtons">
			<td colspan="2">
			<button id="startButton">Partir</button>
			<button id="daCapoButton">Da capo</button>
			<button id="toggleSetlistLyricsButton">Mostrar letra</button>
			<button id="stopTuneSetlist">Pr√≥ximo</button>
			</td>	
		</tr>
		<tr id="tlcol0"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol1"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol2"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol3"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol4"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol5"><td>&nbsp;</td><td></td></tr>
		<tr id="tlcol6"><td>&nbsp;</td><td></td></tr>
		<tr id="timebar_row"><td id="progress">&nbsp;</td><td><canvas id="timebar" is="bar-graph"></canvas></td></tr>
	</tbody>
</table>
<span id="no_tune_span">No hay melod√≠a en curso</span>

<span id="setlist_span">
	<div class="middlediv">Setlist<span id="totalDuration"></span></div>

	<table>
		<tbody id="setlistBody">
		</tbody>
	</table>
	<span id="setlistButtons">
		<button type="button" id="saveSetlist" is="setlist-menu"></button>
		<button type="button" id="loadSetlist" is="setlist-menu"></button>
		<button type="button" id="clearSetlist">Borrar setlist</button>
		<button type="button" id="shuffleSetlist">Desordenar setlist</button>
		<button type="button" id="shuffleAllTunes">Desordenar todos</button>
		<button type="button" id="shuffle3Stars">Desordenar ‚≠ê‚≠ê‚≠ê</button>
		<button type="button" id="go_history">Historia</button>
	</span>
</span>
<span id="lyrics_span" style="display:none">
	<div class="middlediv">
		<span>Letra</span>&nbsp;
		<a onclick="formatLyrics(1)" id="col1_link">1Ô∏è‚É£</a>&nbsp;
		<a onclick="formatLyrics(2)" id="col2_link">2Ô∏è‚É£</a>
	</div>
	<table>
		<tbody>
			<tr><td id="col1"></td><td id="col2"></td></tr>
		</tbody>
	</table>
</span>
<span id="crank_span">
	<div class="middlediv">Control tempo</div>
		<span>Ajuste velocidad:</span>
		<span id="velocityText"></span>
		<br>
		<a onclick="set_velocity(-5)" style="cursor:pointer">&#9194;&nbsp;</a>
		<canvas id="velocityGraph" is="needle-bar"></canvas>
		<a onclick="set_velocity(5)" style="cursor:pointer">&nbsp;&#9193;</a>
		<br>
		<span id="crankInfo">
			<br>
			<input type="checkbox" id="tempo_follows_crank" oninput="tempo_follows_crank()">
			<label for="tempo_follows_crank">Tempo sigue manivela</label><br>
			<br>
			<span id="turning">Girando</span>
			<span id="rpsecText">nnn</span>&nbsp;<span>rev/seg</span>&nbsp;
			<canvas id="rpsecGraph" is="needle-bar"></span>
		</span>
</span>	
<span id="register_span" style="display:none">
	<div class="middlediv">Registros</div>
	<span id="registers"></span>
</span>
<div style="width:100%; height:5px"></div>
<div class="footerdiv"></div>
</body>

<script>
// (c) Copyright 2025 Hermann Paul von Borries. All rights reserved.
// MIT License

// PageHeader.setTitle(headerTitle, upAction)
let pageHeader = new PageHeader().setTitle( tlt("Melod√≠a actual"), "tunelist"  );

// LYRIC_COLUMNS can change between 1 and 2, according to user selection
let LYRIC_COLUMNS = 1;
// Store the current tune here
let CURRENT_TUNEID = "" ;

// 
let ROW_MAP = [TLCOL_GENRE, TLCOL_AUTHOR, TLCOL_TIME,
TLCOL_YEAR, TLCOL_INFO, TLCOL_RATING, TLCOL_DATEADDED];
let ROW_NAMES = map_tlcol_names( ROW_MAP );

function assignButtonHandlers(){
	function abh( id, func ){
		let element = document.getElementById(id);
		element.onclick = func ;
	}
	abh( "startButton", startTune );
	abh( "daCapoButton", backSetlist );
	abh( "toggleSetlistLyricsButton", ()=>toggleSetlistLyrics("toggle") );
	abh( "stopTuneSetlist", stopTuneSetlist );
	abh( "clearSetlist", clearSetlist );
	abh( "shuffleSetlist", shuffleSetlist );
	abh( "shuffleAllTunes", shuffleAllTunes );
	abh( "shuffle3Stars", shuffle3Stars );
	abh( "go_history", go_history );

	// Load and save setlist are custom DOM buttons (common.js - class SetlistMenu)
	document.getElementById("loadSetlist").setOperation("loadSetlist", null, multipleSetlists);
	document.getElementById("saveSetlist").setOperation("saveSetlist", null, multipleSetlists);
}

async function fillSetlistTable(){
	
	// Called once at start of page to fill setlist table
	let tunelib = await tunelibCache.get() ;

	let setlistBody = document.getElementById("setlistBody");
	setlistBody.innerHTML = "";

	for( const [tuneid, tune] of Object.entries(tunelib)) { 
		let row = insertRow( setlistBody, ["", "", "","","","", ""] );
		row.style.display = "none";
		row.id = tune[TLCOL_ID];
		let tuneTitle = document.createElement( "span", {"is":"tune-title"});
		// full format is "hpt%mds"
		// m = microphone if lyrics, d=duration, s=spectator
        tuneTitle.setTune( tune, { beforeFormat:"", afterFormat:"mds", shortClick:false, menu:multipleSetlists } );
        row.cells[1].appendChild( tuneTitle );

		// All lines except the first have up and top icon
		let b2 = document.createElement("button");
		b2.onclick = function(){ upSetlist(tuneid) };
		b2.innerText = " üîº "; // &#128316; Upwards button
		b2.classList.add("minibutton");
		row.cells[2].appendChild( b2 );

		let b3 = document.createElement("button");
		b3.onclick = function(){ downSetlist(tuneid) };
		b3.innerText = " üîΩ "; // &#128317; Downwards button
		b3.classList.add("minibutton");
		row.cells[3].appendChild( b3 );

		let b4 = document.createElement("button");
		b4.onclick = function(){ topSetlist(tuneid) };
		//b4.innerText = " üîù "; //&#128285; "top arrow" icon
		b4.innerText = " ‚è´ ";
		b4.classList.add("minibutton");
		row.cells[4].appendChild( b4 );

		let b5 = document.createElement("button");
		b5.onclick = function(){ bottomSetlist(tuneid) };
		b5.innerText = " ‚è¨ "; // Wastebasket  &#128465;
		b5.classList.add("minibutton");
		row.cells[5].appendChild( b5 );


		let b6 = document.createElement("button");
		b6.onclick = function(){ dropSetlist(tuneid) };
		b6.innerText = " üóëÔ∏è "; // Wastebasket  &#128465;
		b6.classList.add("minibutton");
		row.cells[6].appendChild( b6 );

	}
}

function listsEqual( l1, l2 ){
	let element = 0;
	let i = 0;
	if( l1.length == l2.length &&
		l1.every( (element, i) => element == l2[i] ) ){
		// No change in setlist
		return true;
	}
	return false;
}

function updateSetlistTable(setlist, tunelib){

	let setlistBody = document.getElementById("setlistBody");

	for( const [tuneid, tune] of Object.entries(tunelib)){
        const in_setlist = setlist.includes(tuneid);
		let position = null;
		const row = document.getElementById(tuneid);
		if( in_setlist ){
			position = setlist.indexOf( tuneid ) + 1 ;
			row.cells[0].innerText = ""+position;
			row.style.display = "";
			if( position == 1 ){
				// hide 2=up and 4=top
				row.cells[2].childNodes[0].style.display = "none";
				row.cells[3].childNodes[0].style.display = "";
				row.cells[4].childNodes[0].style.display = "none";
				row.cells[5].childNodes[0].style.display = "";
			}
			else if( position == setlist.length ){
				// hide 3=down and 5=bottom
				row.cells[2].childNodes[0].style.display = "";
				row.cells[3].childNodes[0].style.display = "none";
				row.cells[4].childNodes[0].style.display = "";
				row.cells[5].childNodes[0].style.display = "none";
			}
			else{
				// Make all visible
				row.cells[2].childNodes[0].style.display = "";
				row.cells[3].childNodes[0].style.display = "";
				row.cells[4].childNodes[0].style.display = "";
				row.cells[5].childNodes[0].style.display = "";
			}
		}
		else {
			// If not in setlist, hide row
			row.style.display = "none";
			// All rows not in setlist are sorted to the end
			// of the table
			if( row.cells[0].innerText != "99999"){
				row.cells[0].innerText = "99999";
			}
		}
	}
	sortSetlist();

}
let multipleSetlists = false;
async function pageRefreshProcess() {	
	// This is the "main program" for this page

	// Get this configuration option once and for all
	multipleSetlists = await isMultipleSetlistsEnabled();

	// Assign event listeners to buttons
	assignButtonHandlers();
	
	document.getElementById("timebar").setParam( 60, 0, 100 );
	document.getElementById("velocityGraph").setParam( 60, -50, 50, 0 );
	document.getElementById("rpsecGraph").setParam( 60, 0, 2, 0 );
	// Fill page, then start refresh cycle
	await fillSetlistTable();

	commonGetProgress.setSleep( 2_000 );
    commonGetProgress.registerCallback( updateProgress );
	commonGetProgress.setReloadIfTunelibChanged( true );
    commonGetProgress.startBackground();
	// fill lyrics cache in parallel 
	await lyricsCache.get(); // make sure lyrics are cached
}

let previous_setlist = [];
async function updateProgress( progress ) {
	// Called by commonGetProgress every few seconds with the progress

    if( progress == undefined ){
        return ;
    }
	let tunelib = progress["tunelib"]; 

    let tune_requests = progress["tune_requests"] ;
    if( tune_requests == undefined ){
        tune_requests = {} ;
    }

	let startButton = document.getElementById("startButton");
	let daCapoButton = document.getElementById("daCapoButton");
    if( progress["status"] == "waiting" ){
        startButton.classList.remove("inactive");
		daCapoButton.classList.add("inactive");
    }
    else {
        startButton.classList.add("inactive");
		daCapoButton.classList.remove("inactive");
    }

	let toggle_button = document.getElementById("toggleSetlistLyricsButton") ;
    let s = "" ;
	// CURRENT_TUNEID is a global variable on this page
	// Remember if this refresh changes the current tune
	let tune_change = progress["tune"] != CURRENT_TUNEID ;
	CURRENT_TUNEID = progress["tune"] ;
	if( CURRENT_TUNEID == null || CURRENT_TUNEID == undefined ) {
		// No tune playing nor pending
		showHideElement( "main_info_table", false );
		showHideElement( "no_tune_span", true ) ;
        
		textById("progress", "...") ;
		document.getElementById("timebar").draw( 0 );
		toggle_button.classList.add("inactive");;
		let col1 = document.getElementById( "col1") ;
    	col1.innerText ="" ;
		// Make sure to show setlist controls if no tune
	    await toggleSetlistLyrics( "setlist" ) ;
	}
	else {
		let tune = tunelib[CURRENT_TUNEID] ;
		if( tune != undefined ){
			showHideElement( "main_info_table", true );
			showHideElement( "no_tune_span", false ) ;

			// better do not use spectator format of title here
			let spectator_name = tune_requests[CURRENT_TUNEID];
			textById( "spectator_name",  spectator_name );
			showHideElement( "request_row", spectator_name );

			let tt = document.getElementById("title");
			// full format is "hptm%ds"
			// No menu on tune used as title of page
			tt.setTune( tune, { beforeFormat:"", afterFormat:"m", shortClick:false, menu:multipleSetlists })

			for( let i=0; i<ROW_MAP.length; i++ ){
				let tlcol = ROW_MAP[i];
				let row = document.getElementById("tlcol" + i); 
				row.childNodes[0].innerText = ROW_NAMES[i] ;
				let data = tune[tlcol] ;
				if( tlcol == TLCOL_TIME ){
					data = formatMilliMMSS( tune[TLCOL_TIME] );
				}
				else if( tlcol == TLCOL_RATING ){
					data = formatRating(tune) ;
				}
				row.childNodes[1].innerText = data ;
				row.style.display = (data!="" ? "" : "none");
			}

			// Update progress bar every second, first call
			let percent = progress["playtime"]/tune[TLCOL_TIME]*100 ; // Time
			status_text = make_status_text( progress["status"], percent ) ;
			textById("progress", status_text) ;
			document.getElementById("timebar").draw( percent );
			// >>> may be interesting to show air consumption graph
			// >>> to alert of more air needed ahead of time.
			// >>> It's better to correct MIDI files beforehand.
			// >>> see if instant air consumption is useful.
		}
		// format and set page fields with lyrics
		if( tune && tune[TLCOL_LYRICS] ){
			// There are lyrics: activate button to toggle setlist/lyrics
			toggle_button.classList.remove("inactive"); ;
		}
		else{
			// Mark button as hidden
			toggle_button.classList.add("inactive");
		}
		// start always showing setlist, button caption "Show lyrics"
		if( tune_change ){
			// If tune changed, format lyrics (if any) for 1 column
			await formatLyrics( 1 ) ;
			// Show setlist, button caption "Show lyrics"
			await toggleSetlistLyrics( "setlist" );
		}
		
	}

	let setlist = progress["setlist"] ;
	if( !listsEqual( setlist, previous_setlist ) ){
		updateSetlistTable(setlist, tunelib);
		TuneTitle.updateProgress( progress );
		previous_setlist = setlist;
	}
	let totalDuration = 0;
	for( let tuneid of setlist ){
		if( tuneid in tunelib ){
		    totalDuration += tunelib[tuneid][TLCOL_TIME];
		}
	}
	document.getElementById("totalDuration").innerHTML = "&nbsp;" + Math.round( totalDuration/60_000 ) +"min";

	// Always update velocity and RPS
	let vel = progress["velocity"];
	document.getElementById("velocityGraph").draw( vel-50 );
	let velmult = progress["tempo_multiplier"] ;
	let velText = "" ;
	if( !isNaN(velmult)){
		velText = "" + Math.round( velmult*10 )/10 + "x " ;
	}
	textById("velocityText", velText );
	let rpsec = progress["rpsec"] ;

	
	if( progress["tacho_installed"] ){
		let rt = Math.round( progress["rpsec"]*10)/10 ;
		document.getElementById("crankInfo").style.display = "" ;
		if( progress["is_turning"] ) {
			textById("turning", tlt("Girando"));
		}
		else {
			textById("turning", tlt("No gira"));
		}
		textById("rpsecText", "" + rt) ;

		let rpsecGraph = document.getElementById("rpsecGraph");
		let config = await configCache.get();
		if( rpsec <= config["lower_threshold_rpsec"]){
			rpsecGraph.barColor = meter_red_color ;
		}
		else if( rpsec <= config["higher_threshold_rpsec"]){
			rpsecGraph.barColor = sandy ;
		}
		else {
			rpsecGraph.barColor = meter_green_color ;
		}

        document.getElementById("rpsecGraph").draw( rpsec );
        f = document.getElementById("tempo_follows_crank");
        f.checked = progress["tempo_follows_crank"] ;
	}
	else {
		document.getElementById("crankInfo").style.display = "none" ;	
	}
	
	if( progress["registers"] && progress["registers"].length > 0 ){
		let registers = progress["registers"];
		
		showHideElement( "register_span", true );
		// Check if all registers are displayed
		let regs = document.getElementById("registers");
		for( let i in registers ){
			let reg_name = registers[i][0];
			d = document.getElementById( "reg_" + reg_name );
			if( !d ){
				let regcheck = document.createElement( "input" );
				regcheck.type = "checkbox";
				regcheck.id = `reg_${reg_name}`;
				regcheck.onclick = function(){ toggleRegister( reg_name )};
				// add check box for register if not there
				regs.appendChild( regcheck );
				let regspan = document.createElement( "span" );
				regspan.innerText = reg_name ;
				regs.appendChild( regspan );
				let regbr = document.createElement( "br" );
				regs.appendChild( regbr );
			}
		}
		// Show register values
		for( let i in registers ){
			let reg_name = registers[i][0];
			let reg_value = registers[i][1];
			document.getElementById( "reg_" + reg_name ).checked = Boolean( reg_value ) ;
		}
	}
	if( isUsedFromIOT() ){
		// If this page is residing on drehorgel.pythonanywhere.com
		// disable non-functional buttons (no action on this server)
		document.getElementById("setlistButtons").style.display = "none";

		// No progress during tunes, since mcserver is disabled during tune
		// No 1/2 column select, may be too confusing
		
		document.getElementById("crank_span").style.display = "none";
		document.getElementById("lyrics_span").style.display = "";
		document.getElementById("setlist_span").style.display = "none";
		document.getElementById("register_span").style.display = "none";
		
		document.getElementById("col1_link").style.display = "none" ;
		document.getElementById("col2_link").style.display = "none" ;
		document.getElementById("timebar").style.display = "none";
		document.getElementById("progress").style.display = "none";
		
		let d = document.getElementById("controlButtons");
		d.style.display = "none" ;

	}
}

async function shuffleAllTunes() {
	await commonGetProgress.fetchJson( "/shuffle_all_tunes" ) ;
}
async function shuffle3Stars(){
	await commonGetProgress.fetchJson("/shuffle_3stars" ) ;

}
async function shuffleSetlist() {
	await commonGetProgress.fetchJson("/shuffle_set_list" ) ;
}

async function clearSetlist() {
	await commonGetProgress.fetchJson("/clear_setlist" );
}

async function upSetlist(tuneid) {
	await commonGetProgress.fetchJson("/up_setlist/" + tuneid );
}

async function downSetlist(tuneid) {
	await commonGetProgress.fetchJson("/down_setlist/" + tuneid );
}

async function dropSetlist(tuneid) {
	await commonGetProgress.fetchJson("/drop_setlist/" + tuneid );
}

async function topSetlist(tuneid) {
	await commonGetProgress.fetchJson("/top_setlist/" + tuneid );
}

async function bottomSetlist(tuneid) {
	await commonGetProgress.fetchJson("/bottom_setlist/" + tuneid );
}

async function set_velocity( increment ) {
	await commonGetProgress.fetchJson( "/set_velocity_relative/" + increment );
}

async function check_cancelled( ) {
    // When cancelling refresh faster to skip transitions
	// and have better response time
	let progress = await commonGetProgress.getProgress() ;
	let i = 4; // don't iterate forever here...
	while( i > 0 ){
        if( progress["status"] != "cancelled" ){
            break ;
        }
        progress = await commonGetProgress.getProgress() ;
		i -= 1;
    }
    return progress ;
}
    
async function startTune() {
    await commonGetProgress.fetchJson( "/start_tune" ) ;
}

async function stopTuneSetlist() {
	await commonGetProgress.fetchJson("/stop_tune_setlist" ) ;
    await check_cancelled( ) ;
	await commonGetProgress.getProgress();  // >>> necessary???
}

async function backSetlist() {
	await commonGetProgress.fetchJson( "/back_setlist" ) ;
    await check_cancelled() ;
	await commonGetProgress.getProgress( ) ;// >>> necessary???
}
    
async function tempo_follows_crank(){
    let f = document.getElementById("tempo_follows_crank");
    let data = { "tempo_follows_crank": f.checked };
    await commonGetProgress.fetchJson( "/tempo_follows_crank", data );
}

function go_history(){
	window.location.href = "/static/history.html" ;
}

async function toggleSetlistLyrics( what ){
	let tunelib = await tunelibCache.get() ;
	let tune = tunelib[CURRENT_TUNEID] ;
	let has_lyrics =  tune && tune[TLCOL_LYRICS];

	// what can be "setlist", "lyrics" or "toggle"
	// what="setlist" setlist is shown, button caption is "Show lyrics"
	// what="lyrics" lyrics are shown, button caption is "Show setlist"
	// what="toggle" toggles between setlist and lyrics
	let setlist_span =  document.getElementById( "setlist_span") ;
	let lyrics_span =  document.getElementById( "lyrics_span") ;
	let toggle_button = document.getElementById( "toggleSetlistLyricsButton" ) ;
	let show = what;
	if( what == "toggle" ){
		// If no what, toggle between setlist and lyrics
		show = setlist_span.style.display == "none" ? "setlist" : "lyrics" ;
	}
	if( !has_lyrics ){
		// If no lyrics, always show setlist (don't allow to toggle)
		show = "setlist" ;
	}
	if( show == "setlist" ){
		setlist_span.style.display = "";
		lyrics_span.style.display = "none" ;
		toggle_button.innerText = tlt("Mostrar letra") ;
	}
	else{
		setlist_span.style.display = "none";
		lyrics_span.style.display = "" ;
		toggle_button.innerText = tlt("Mostrar setlist") ;
	}
}

async function formatLyrics(c){
	// store desired columns in global variable "LYRIC_COLUMNS"
	// c should be 1 or 2
	LYRIC_COLUMNS = c ;
	// Format lyrics to one or two columns
	let col1 = document.getElementById( "col1") ;
	let col2 = document.getElementById( "col2") ;
	let lyrics = await lyricsCacheTuneid( CURRENT_TUNEID ) ;
	if( LYRIC_COLUMNS == 1 ){
		col1.innerText = lyrics ;
		col1.colSpan = 2 ;
		col2.innerText = "";
	}
	else{
		// Format lyrics in two columns, search for \n in the middle
		let i = Math.round(lyrics.length/2) ;
		while( i < lyrics.length ){
			if( lyrics.substring(i,i+1) == "\n"){
				break ;
			}
			i = i + 1 ;
		}
		// Split in two halves, trim \n and spaces at the beginning/end
		let l1 = lyrics.substring(0,i+1);
		let l2 = lyrics.substring(i);
		col1.innerText = l1.trim() ;
		col1.colSpan = 1 ;
		col2.innerText = l2.trim();

	}
	return lyrics;
}

async function toggleRegister( reg_name ){
	let value = document.getElementById( `reg_${reg_name}`).checked;
	await commonGetProgress.fetchJson( "/toggle_register",
				 	{"name": reg_name, "value": value} );
}

function sortSetlist() {

    const tbody = document.getElementById("setlistBody");
    const rows = Array.from(tbody.querySelectorAll("tr"));
    rows.sort((rowA, rowB) => {
        return parseInt(rowA.cells[0].textContent) - parseInt(rowB.cells[0].textContent); 
    });

    // Clear and re-append rows
    rows.forEach(row => tbody.appendChild(row));
}

function make_status_text( progress_status, percentage ) {
	// Transform player status to language
    let status_text ;
	if (progress_status === "ended") {
		status_text = tlt("termin√≥") ;
	}
	else if(progress_status === "playing" ) {
		status_text = "" + Math.round(percentage) + "%" ;
	}
	else if(progress_status === "cancelled" ) {
		status_text = tlt("cancelado") ;
	}
    else if( progress_status == "waiting"){
        status_text = "‚è≥ " + tlt("en espera") ; // U+23F3 hourglass with flowing sand
    }
	else {
		status_text = progress_status ;
	}
	return status_text ;
}

translate_html();
pageRefreshProcess() ;


</script>
</html>