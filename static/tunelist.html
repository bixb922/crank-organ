<!DOCTYPE html>
<!-- (c) Copyright 2025 Hermann Paul von Borries. All rights reserved.
 MIT License -->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="stylesheet" type="text/css" href="skeleton.css">
</head>

<body>

<script type="text/javascript" src="/static/common.js"></script>
<script type="text/javascript" src="/static/translations.js"></script>

	<input type="text" id="searchInput"
           placeholder="üîçB√∫squeda"
           onkeyup="filterTable()"
           size="10"/>
	<button id="navigateToPlayPage" type="button" onclick="navigateToPlayPage()">Actuaci√≥n</button>
    <button id="startButton" onclick='startTune()'>Partir</button>

    <div class="tableFixHead">
      <table id="tunelisttable">
          <thead id="tunelisthead">
            <tr id="headerRow"></tr>
          </thead>
          <tbody id="tunelistbody">
          </tbody>
      </table>
    </div>
</body>

<script>


document.getElementById("searchInput").placeholder = tlt("üîçB√∫squeda");

// PageHeader.setTitle(headerTitle, upAction)
let pageHeader = new PageHeader().setTitle( tlt("Lista de melod√≠as"), "index" );

// keep sorted list in global page context

let HEADERMAP = [ TLCOL_TITLE, TLCOL_GENRE, TLCOL_AUTHOR, TLCOL_TIME, TLCOL_YEAR, TLCOL_HISTORY, TLCOL_INFO, TLCOL_DATEADDED, TLCOL_RATING ];
let HEADER = map_tlcol_names( HEADERMAP );
HEADER[3] = "mm:ss"; // time column is in mm:ss format

// Current order
let sortColumn = 0 ;
let direction = 1 ; // sort direction must be 1 or -1


// Keep track of which rows are visible
function tunelistVisibilityChanges( entries ){
    // Page has scrolled, update TitleTunes that entered/exited viewport.
    for( let entry of entries ){
        // Add/remove class according to visibility in viewport
        if( entry.isIntersecting ){
            entry.target.classList.add("tunelist-visible");
        }
        else{
            entry.target.classList.remove("tunelist-visible");
        }
    }
}

// Called when loading page
async function pageRefreshProcess( ) {
    if( isUsedFromIOT() ){
        document.getElementById( "navigateToPlayPage").style.display = "none" ;
        document.getElementById( "startButton").style.display = "none" ;
    }
    
    fillHeader( );
    await fillBody( ) ;
    changeOrder( 0 );


    // Refresh progress periodically
    commonGetProgress.setSleep( 2_000 );
    commonGetProgress.registerCallback( updateProgress );
    commonGetProgress.setReloadIfTunelibChanged( true );
    await sleep_ms(100); // to avoid forcing reflow
    // Start background will trigger a updateProgress very soon.
    commonGetProgress.startBackground();

}

function fillHeader( ){
    let headerRow = document.getElementById("headerRow");
    headerRow.innerHTML = "";
    for (let col = 0 ; col < HEADER.length ; col++ ){
        let arrow = ""
        if( col == sortColumn ){
            arrow = direction > 0 ? "‚Üë " : "‚Üì ";
        }
        let th = document.createElement("th");
        th.textContent = arrow + HEADER[col];
        th.style.cursor = "pointer";
        th.onclick = function() { changeOrder(col) };
        headerRow.appendChild( th );
    }
}
let fastSearch = [];

async function fillBody( ) {
    let s = "";
    let tlbody = document.getElementById( "tunelistbody")
    tlbody.innerHTML = "";  
    let tunelib = await tunelibCache.get(); // common.js
    let multipleSetlists = await isMultipleSetlistsEnabled();
    let n = 0;
    for( const [tuneid, tune] of Object.entries(tunelib)) {
        let row = insertRow( tlbody, ["",tune[TLCOL_GENRE],
                tune[TLCOL_AUTHOR], formatMilliMMSS( tune[TLCOL_TIME] ),
                tune[TLCOL_YEAR], tune[TLCOL_HISTORY],
                "", tune[TLCOL_DATEADDED], formatRating(tune)] );

        let tuneTitle = document.createElement( "span", {"is":"tune-title"});
        // full format is "hptm%ds"
        tuneTitle.setTune( tune, { beforeFormat:"hpt", afterFormat:"m%s", shortClick:true, menu:multipleSetlists } );
        row.cells[0].appendChild( tuneTitle );

        row.cells[5].style.textAlign = "right"; // history

        let infoLink = document.createElement("a");
        infoLink.classList.add( "anohref" );
        infoLink.onclick = function(){ showFullInfo(tuneid) };
        infoLink.innerText = trunc(tune[TLCOL_INFO],10);
        row.cells[6].appendChild( infoLink );

        // For the search functionality, we need to normalize the tune text
        // and store it in a global array for fast search. 
        // And add row.id to be able to decode the row number in filterTable().
        row.id = "r" + n;
        n += 1;
        s = tune[TLCOL_TITLE] + "\t" +
            tune[TLCOL_GENRE] + "\t" +
            tune[TLCOL_AUTHOR] + "\t" +
            formatMilliMMSS( tune[TLCOL_TIME] ) + "\t" +
            tune[TLCOL_YEAR] + "\t" +
            tune[TLCOL_INFO] + "\t" +
            tune[TLCOL_DATEADDED] + "\t" +
            tune[TLCOL_RATING] ;
        fastSearch.push( normalizaTildes(s) );
	}
}

function navigateToPlayPage() {
	window.location.href = "/static/play.html" ;
}

    
function updateProgress( progress ) {
    let tunelib = progress["tunelib"];

    let startButton = document.getElementById("startButton");
    if( progress["setlist"].length > 0 && 
        progress["status"] == "waiting"
    ){
        startButton.classList.remove("inactive");
    }
    else {
        startButton.classList.add("inactive");
    }
    TuneTitle.updateProgress( progress );

}

function changeOrder(column) {
    // Helper to get cell value, normalized for text comparison
    function getCellValue(row, col) {
        return row.cells[col].textContent.trim().toLowerCase();
    }
    // Compare as text
    function compareText(rowA, rowB) {
        let a = getCellValue(rowA, column);
        let b = getCellValue(rowB, column);
        return b.localeCompare(a) * direction;
    }
    // Compare as number (fallback to text if not a number)
    function compareNum(rowA, rowB) {
        let a = getCellValue(rowA, column);
        let b = getCellValue(rowB, column);
        if (isNaN(a) || isNaN(b)) return compareText(rowA, rowB);
        a = parseInt(a);
        b = parseInt(b);
        return (b - a) * direction;
    }

    // Toggle direction if same column, else set new column and default direction
    if (column === sortColumn) {
        direction = -direction;
    } else {
        sortColumn = column;
        direction = -1;
    }

    fillHeader();

    let tbody = document.getElementById("tunelistbody");
    let rows = Array.from(tbody.rows);

    // Choose comparison based on column type
    let compareFn = (HEADERMAP[sortColumn] === TLCOL_HISTORY) ? compareNum : compareText;
    rows.sort(compareFn);

    // Re-append sorted rows
    tbody.replaceChildren(...rows);
}

function trunc( text, n ){
    if( text.length < n ){
        return text ;
    }
    return text.substring(0,n-3) + "...";
}
async function showFullInfo(tuneid){
    let tunelib = await tunelibCache.get() ;
    let tune = tunelib[tuneid] ;
    if( tune == undefined ){
        return;
    }
    let info = tune[TLCOL_INFO] ;
    showPopup( "", info ) ;
}

async function startTune() {
    // This will call updateProgress in turn:
    await commonGetProgress.fetchJson( "/start_tune" );
}

// Search functionality

// Function to translate some commo characters with accent and tilde
// to their non-accented equivalents.
// This is used to normalize the search input and the table content.
// This does not cover all languages.
let   from = "√É√Ä√Å√Ñ√Ç√à√â√ã√ä√å√ç√è√é√í√ì√ñ√î√ô√ö√ú√õ√£√†√°√§√¢√®√©√´√™√¨√≠√Ø√Æ√≤√≥√∂√¥√π√∫√º√ª√ë√±√á√ß", 
      to   = "aaaaaeeeeiiiioooouuuuaaaaaeeeeiiiioooouuuunncc",
      mapping = {};
 
for(let i = 0, j = from.length; i < j; i++ )
      mapping[ from.charAt( i ) ] = to.charAt( i );
 
function normalizaTildes( str ) {
    let m = [...str].map( (c) => {
        if( mapping.hasOwnProperty(c) ){
            return mapping[c];
        }
        return c;
    });
    return m.join("").toLowerCase();
 }


function filterTable() {
    let filter = normalizaTildes( document.getElementById("searchInput").value ) ;
    let rowList = document.getElementById("tunelistbody").rows;
    for( let row of rowList){
        let rowText = fastSearch[ parseInt(row.id.substring(1)) ]; // id of row is "r0", "r1", etc.
        row.style.display = rowText.includes(filter) ? "" : "none";
    }
}

translate_html();

// pageRefreshProcess will call updateProgressEvery the first time,    
// and then will continue refreshing
pageRefreshProcess() ;


</script>
</html>